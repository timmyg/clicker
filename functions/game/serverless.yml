service: game
frameworkVersion: '>=1.1.0 <2.0.0'
provider:
  name: aws
  memorySize: 128
  versionFunctions: false
  runtime: nodejs10.x
  # tracing: true
  logRetentionInDays: 14
  deploymentBucket:
    name: serverless-deploys-clicker
  environment:
    stage: ${self:custom.stage}
    serviceName: ${self:service}
    tableGame: ${self:custom.tableGame}
    airtableKey: ${env:AIRTABLE_KEY}
    airtableBase: ${self:custom.airtableBase.${self:custom.stage}}
  iamRoleStatements:
    - Effect: 'Allow'
      Action:
        - dynamodb:*
        - lambda:InvokeFunction
        - lambda:InvokeAsync
        - xray:PutTraceSegments
        - xray:PutTelemetryRecords
      Resource: '*'
    # - Effect: Allow
    #   Action:
    #     - SNS:Publish
    #   Resource:
    #     {
    #       'Fn::Join':
    #         ['', ['arn:aws:sns:${self:provider.region}:', { 'Ref': 'AWS::AccountId' }, ':${self:custom.newGameTopic}']],
    #     }
    # - Effect: Allow
    #   Action:
    #     - SNS:Publish
    #   Resource:
    #     {
    #       'Fn::Join':
    #         [
    #           '',
    #           ['arn:aws:sns:${self:provider.region}:', { 'Ref': 'AWS::AccountId' }, ':${self:custom.updatedGameTopic}'],
    #         ],
    #     }
plugins:
  - serverless-domain-manager
  - serverless-prune-plugin
  - serverless-sentry
  - serverless-dotenv-plugin
  - serverless-plugin-tracing

custom:
  stage: ${opt:stage, self:provider.stage}
  tableGame: games-${self:custom.stage}
  prune:
    automatic: true
    number: 3
  domains:
    prod: api.tryclicker.com
    release: api-release.tryclicker.com
    develop: api-develop.tryclicker.com
  airtableBase:
    prod: ${env:AIRTABLE_BASE}
    release: ${env:AIRTABLE_BASE_RELEASE}
    develop: ${env:AIRTABLE_BASE_DEV}
  customDomain:
    domainName: ${self:custom.domains.${self:custom.stage}}
    basePath: games
    certificateName: 'api.tryclicker.com'
    stage: ${self:custom.stage}
    createRoute53Record: true
    endpointType: 'edge'
  sentry:
    dsn: ${env:SENTRY_DSN_ENDPOINT}
  dotenv:
    basePath: ../
  # updatedGameTopic: '${self:service}-${self:custom.stage}-updated-game-topic'
  # updatedGameTopicArn:
  #   deployed:
  #     {
  #       'Fn::Join':
  #         [
  #           '',
  #           ['arn:aws:sns:${self:provider.region}:', { 'Ref': 'AWS::AccountId' }, ':${self:custom.updatedGameTopic}'],
  #         ],
  #     }
resources:
  Resources:
    GamesTable:
      Type: 'AWS::DynamoDB::Table'
      Properties:
        TableName: ${self:custom.tableGame}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: N
          - AttributeName: status
            AttributeType: S
          - AttributeName: start
            AttributeType: S
        KeySchema:
          - AttributeName: start
            KeyType: HASH
          - AttributeName: id
            KeyType: RANGE
        GlobalSecondaryIndexes:
          - IndexName: statusGlobalIndex
            KeySchema:
              - AttributeName: status
                KeyType: HASH
            Projection:
              ProjectionType: ALL
          - IndexName: idGlobalIndex
            KeySchema:
              - AttributeName: id
                KeyType: HASH
            Projection:
              ProjectionType: ALL
    # updated game stuff (score update)
    # updatedGameTopic:
    #   Type: AWS::SNS::Topic
    #   Properties:
    #     TopicName: ${self:service}-${self:custom.stage}-updated-game-topic
    # updatedGameQueue:
    #   Type: AWS::SQS::Queue
    #   Properties:
    #     QueueName: ${self:service}-${self:custom.stage}-updated-game-queue
    #     RedrivePolicy:
    #       deadLetterTargetArn: !GetAtt
    #         - updatedGameDLQ
    #         - Arn
    #       maxReceiveCount: 3
    # updatedGameDLQ:
    #   Type: AWS::SQS::Queue
    #   Properties:
    #     QueueName: ${self:service}-${self:custom.stage}-updated-game-queue-dlq
    # snsToUpdatedGameQueueSqsPolicy:
    #   Type: AWS::SQS::QueuePolicy
    #   Properties:
    #     PolicyDocument:
    #       Version: '2012-10-17'
    #       Statement:
    #         - Sid: 'allow-sns-messages'
    #           Effect: Allow
    #           Principal: '*'
    #           Resource: !GetAtt
    #             - updatedGameQueue
    #             - Arn
    #           Action: 'SQS:SendMessage'
    #           Condition:
    #             ArnEquals:
    #               'aws:SourceArn': !Ref updatedGameTopic
    #     Queues:
    #       - Ref: updatedGameQueue
    # updatedGameQueueSubscription:
    #   Type: 'AWS::SNS::Subscription'
    #   Properties:
    #     TopicArn: !Ref updatedGameTopic
    #     Endpoint: !GetAtt
    #       - updatedGameQueue
    #       - Arn
    #     Protocol: sqs
    #     RawMessageDelivery: 'true'
functions:
  health:
    handler: game.health
    events:
      - http:
          path: health
          method: get
          cors:
            origin: '*'
            headers:
              - partner
              - authorization
  getStatus:
    handler: game.getStatus
    events:
      - http:
          path: 'score'
          method: post
          cors:
            origin: '*'
            headers:
              - partner
              - authorization
              - content-type
  syncNextFewDays:
    handler: game.syncNextFewDays
    memorySize: 1024
    timeout: 30
    # environment:
    #   newGameTopicArn: ${self:custom.newGameTopicArn.deployed}
    events:
      - schedule: cron(00 9 * * ? *) # every day @ 5:00am eastern
      - http:
          path: 'sync'
          method: post
          cors:
            origin: '*'
            headers:
              - partner
              - authorization
              - content-type
  syncActive:
    handler: game.syncActive
    memorySize: 1024
    timeout: 12
    # environment:
    # newGameTopicArn: ${self:custom.newGameTopicArn.deployed}
    # updatedGameTopicArn: ${self:custom.updatedGameTopicArn.deployed}
    events:
      - schedule: cron(0/2 21-4 ? * * *) # Every 2 minutes between 11pm UTC and 4am UTC
      - schedule: cron(0/10 4-21 ? * * *) # Every 10 minutes between 4am UTC and 9pm UTC
      - http:
          path: sync/scores
          method: post
          cors:
            origin: '*'
            headers:
              - partner
              - authorization
              - content-type
  syncAirtable:
    handler: game.syncAirtable
    timeout: 30
    memorySize: 1024
    # environment:
    #   newGameTopicArn: ${self:custom.newGameTopicArn.deployed}
    events:
      - schedule: cron(00 10 * * ? *) # every day @ 6:00am eastern
      - http:
          path: sync/airtable
          method: post
          cors:
            origin: '*'
            headers:
              - partner
              - authorization
              - content-type
  get:
    handler: game.get
    events:
      - http:
          path: '{id}'
          method: get
  # getByStartTimeAndNetwork:
  #   handler: game.getByStartTimeAndNetwork
  #   events:
  #     - http:
  #         path: search
  #         method: get
  #         cors:
  #           origin: '*'
  #           headers:
  #             - partner
  #             - authorization
  #             - content-type
  scoreboard:
    handler: game.scoreboard
    memorySize: 1024
    events:
      - http:
          path: scoreboard
          method: get
          cors:
            origin: '*'
            headers:
              - partner
              - authorization
              - content-type
  updateAirtableGamesStatus:
    handler: game.updateAirtableGamesStatus
    timeout: 30
    events:
      - schedule: cron(0/2 21-4 ? * * *) # Every 2 minutes between 11pm UTC and 4am UTC
      - schedule: cron(0/10 4-21 ? * * *) # Every 10 minutes between 4am UTC and 9pm UTC
      - http:
          path: airtable/live/status
          method: put
